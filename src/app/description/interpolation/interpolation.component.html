<mat-card>
  <mat-card-title>{{ data.name }}</mat-card-title>
  <mat-card-content>
    <p>{{ sText }}</p>
  </mat-card-content>
</mat-card>
<tr></tr>
<mat-card>
  <mat-card-title>Контекст выражений</mat-card-title>
  <mat-card-content>
    <p>
      Выражения имеют контекст использования, то куда они вставляются. выражение
      может ссылать на атрибут HTML-элемента или выстраивать более сложные
      конструкции Angular вставками *ngFor или метка HTML элементов #Id.
    </p>
    <div (keyup)="(0)" class="context">
      Напечатайте что-то:
      <input #heroInput /> {{ heroInput.value }}
    </div>
  </mat-card-content>
</mat-card>
<mat-card>
  <mat-progress-bar
    mode="determinate"
    color="warn"
    value="100"
  ></mat-progress-bar>

  <mat-card-content>
    <p>
      Шаблонные выражения не могут ссылаться на глобальый контекст кроме
      underfined, не могут вызвать console.log() или Math.max(), не могут
      ссылаться на window/document. Могут ссылаться на члены контекста
      выражения.
    </p>
  </mat-card-content>

  <mat-progress-bar
    mode="determinate"
    color="warn"
    value="100"
  ></mat-progress-bar>
</mat-card>
<mat-card>
  <mat-card-title>Именные коллизии </mat-card-title>
  <mat-card-content>
    <p>
      Контекст на который ссылается выражение это объединения шаблона и
      переменных, контекстовых директив, объектов и участников компонента, если
      вы ссылается на имя принадлижащее более чем одному элементу в
      пространствеимён Angular реализует следующую логику: 1) шаблонные
      переменные 2)имена в контекстах директив 3) имена участников в компонента
    </p>
  </mat-card-content>
</mat-card>
<tr></tr>
<mat-card>
  <mat-card-title>Лучшие практики с выражениями </mat-card-title>
  <mat-card-content>
    <p>когда используете выражения :</p>
    <ul>
      <li>Короткие выражения</li>
      <li>
        Быстрое исполнение.
        <p>
          Angular выполняет шаблонные выражения после каждого цикла обнаружения
          изменений. Многие асинхронные действия запускают циклы обнаружения
          изменений, такие как разрешение обещаний, результаты HTTP, события
          таймера, нажатия клавиш и движения мыши. Выражения должны
          заканчиваться быстро, чтобы обеспечить максимальную эффективность
          взаимодействия с пользователем, особенно на медленных устройствах.
          Рассмотрите возможность кэширования значений, когда их вычисление
          требует больших ресурсов.
        </p>
      </li>
      <li>
        без видимогосторонненго эфекта
        <p>
          Согласно модели однонаправленного потока данных Angular, выражение
          шаблона не должно изменять какое-либо состояние приложения, кроме
          значения целевого свойства. Чтение значения компонента не должно
          изменять другое отображаемое значение. Вид должен быть стабильным в
          течение одного прохода рендеринга.
        </p>
      </li>
    </ul>
  </mat-card-content>
</mat-card>
